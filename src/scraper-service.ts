import { PlaywrightCrawler } from "crawlee";
import { router } from "./routes.js";
import { promises as fs } from "fs";
import path from "path";

// Search parameters interface
export interface SearchParams {
  originCode: string;
  destinationCode: string;
  departureDate: string;
  returnDate: string;
  passengers: number;
  destinationCity?: string;
  destinationAirport?: string;
}

// Scraper service class
export class DeltaVacationsScraper {
  constructor() {
    // Constructor is now empty - we'll create crawler instances as needed
  }

  /**
   * Search for vacation packages using the Delta API
   */
  async searchVacations(searchParams: SearchParams): Promise<any> {
    try {
      // Set environment variables for the scraper
      process.env.ORIGIN_CODE = searchParams.originCode;
      process.env.DESTINATION_CODE = searchParams.destinationCode;
      process.env.DEPARTURE_DATE = searchParams.departureDate;
      process.env.RETURN_DATE = searchParams.returnDate;
      process.env.PASSENGERS = searchParams.passengers.toString();
      process.env.DESTINATION_CITY = searchParams.destinationCity || "";
      process.env.DESTINATION_AIRPORT = searchParams.destinationAirport || "";

      console.log(
        `Scraper starting: ${searchParams.originCode} â†’ ${searchParams.destinationCode}`
      );

      // Create a new crawler instance for this request
      const crawler = new PlaywrightCrawler({
        requestHandler: router,
        maxRequestsPerCrawl: 1,
        launchContext: {
          launchOptions: {
            headless: true,
          },
        },
        preNavigationHooks: [
          async ({ blockRequests }) => {
            await blockRequests({
              extraUrlPatterns: ["adsbygoogle.js"],
            });
          },
        ],
        requestHandlerTimeoutSecs: 120,
      });

      // Start the crawler and wait for completion
      const startUrl = "https://www.delta.com/us/en/delta-vacations";
      await crawler.run([startUrl]);

      // Wait a moment for file writing to complete
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Read and return the latest result
      const result = await this.getLatestResult();

      // Teardown the crawler
      await crawler.teardown();

      return result;
    } catch (error: any) {
      console.error("Scraper error:", error.message);
      throw new Error(`Failed to scrape vacation data: ${error.message}`);
    }
  }

  /**
   * Read the latest result from the output files
   */
  private async getLatestResult(): Promise<any> {
    try {
      const outputDir = path.join(
        process.cwd(),
        "storage",
        "datasets",
        "default"
      );
      const files = await fs.readdir(outputDir);
      const jsonFiles = files.filter((f: string) => f.endsWith(".json")).sort();

      if (jsonFiles.length === 0) {
        throw new Error("No results generated by scraper");
      }

      const latestFile = jsonFiles[jsonFiles.length - 1];
      const resultData = await fs.readFile(
        path.join(outputDir, latestFile),
        "utf8"
      );
      const result = JSON.parse(resultData);

      // Validate that this is a properly formatted result
      if (!result.success) {
        throw new Error("Scraper did not return successful result");
      }

      return result;
    } catch (error: any) {
      throw new Error(`Failed to read scraper results: ${error.message}`);
    }
  }

  /**
   * Validate search parameters
   */
  static validateSearchParams(params: any): {
    valid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    if (!params.originCode || typeof params.originCode !== "string") {
      errors.push("originCode is required and must be a string");
    }

    if (!params.destinationCode || typeof params.destinationCode !== "string") {
      errors.push("destinationCode is required and must be a string");
    }

    if (!params.departureDate || typeof params.departureDate !== "string") {
      errors.push(
        "departureDate is required and must be a string (YYYY-MM-DD format)"
      );
    }

    if (!params.returnDate || typeof params.returnDate !== "string") {
      errors.push(
        "returnDate is required and must be a string (YYYY-MM-DD format)"
      );
    }

    if (
      !params.passengers ||
      typeof params.passengers !== "number" ||
      params.passengers < 1 ||
      params.passengers > 9
    ) {
      errors.push(
        "passengers is required and must be a number between 1 and 9"
      );
    }

    // Date format validation
    const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
    if (params.departureDate && !dateRegex.test(params.departureDate)) {
      errors.push("departureDate must be in YYYY-MM-DD format");
    }

    if (params.returnDate && !dateRegex.test(params.returnDate)) {
      errors.push("returnDate must be in YYYY-MM-DD format");
    }

    // Check if return date is after departure date
    if (params.departureDate && params.returnDate) {
      const depDate = new Date(params.departureDate);
      const retDate = new Date(params.returnDate);
      if (retDate <= depDate) {
        errors.push("returnDate must be after departureDate");
      }
    }

    return { valid: errors.length === 0, errors };
  }
}

export default DeltaVacationsScraper;
